---
metadata:
  title: Saving data to the database
  description: Follow these step-by-step tutorials to build a simple To do application on platformOS.
converter: markdown
---

platformOS uses GraphQL as a language of communication with the database, and YAML to build the database structure. The following tutorial will guide you through using those technologies to store and remove a simple set of data.

Don’t worry if you never used any of those before. Both of them are build in a way that makes it easy to jump right into the development and learn as you go. platformOS offers a set of tools to make the development even easier.


## Create the database structure using YAML

The very first step would be to figure out the structure of the dabase we need. For our simple example we will need just a **single database table** in which we will save the **item’s title**.

We would also need an **unique ID** for every record we store, but this part platformOS does **automatically** for us, so we don’t really have to think about it.

| ID | Title                              |
|----|------------------------------------|
| 1  | Do the groceries                   |
| 2  | Clean up in the kitchen            |
| 3  | Build my first app on platformOS   |

To build a database table on platformOS you will have to *create a file* that will tell the platform what _properties_ (or _columns_ if you are used to think about the database as a table) do you need and what type of data would you like to store in them. Those files needs to be placed in a dedicated directory: `/app/schema/`.

To describe the table structure we would use a simple data-serialization language called YAML. For a basic table like ours, we need to create a file named `item.yml`:

#### /app/schema/item.yml

```yaml
name: item
properties:
  - name: title
    type: string

```

In the 1st line we’ve named our table and called it `item`. The 2nd line starts the list of properties that the table will have, those properties we then specify starting with a dash. In our case we need just a single property called `title`. That property will have to be a `string` as we described in the 4th line.

YAML is written in a way that makes it easily readable by humas, so it shouldn't be long untill you’ll get a hang of it. What is important to remember is that the **indentation is very important** here as it basically describes the structure and dependencies in it.

For the sake of having a complete picture of YAML structure, here is an extended example with three properties in the table:

```yaml
name: example
properties:
  - name: name
    type: string
  - name: surname
    type: string
  - name: age
    type: integer
```


## Browse the database tables using platformOS tool

How can we make sure that the table we’ve just created is really there in the database?

For this purpose, we have created a tool that allows you to browse through the tables and edit the records. To start the tool you need to run the following command:

```bash
pos-cli gui serve <instance alias>
```

This will start an application that will help you administrate your instance. When the application is running you can then go to [http://localhost:3333](http://localhost:3333) in your browser.

There is a selection of tools you can use. The one that will allow us to look on the database is the one in the first box. Following _Go to Records_ link will open a list of tables that we’ve created using the YAML files.

If everything went right, you should see the newly created `item` table on the list.

<img loading="lazy" src="{{ 'images/get-started/todo/gui_records.jpg' | asset_url }}" alt="Graphic interface for browsing the database on platformOS">


## Save the data in the database

To actually save some data in the database, we need to start by creating a GraphQL query. The desired directory for those would be `/app/graphql/`.

In this example we do have just a single table in our application, so we could put the file directly in that folder, but when our application will grow, we might consider a more standarized way of organizing the queries.

So, to accomodate for those future grows, let’s save the file in `/app/graphql/item/create.graphql`:

#### /app/graphql/item/create.graphql

```graphql
mutation item_create(
  $title: String
) {
  record: record_create(
    record: {
      table: "item"
      properties: [
        { name: "title", value: $title }
      ]
    }
  ) {
    id
    title: property(name: "title")
  }
}
```

If you never seen GraphQL before it might feel there is a lot going on here.

In the 1st line we are declaring a new _mutation_ – that is a name for any operation inserting new data or modifying an existing one. We are giving the mutation a name – `item_create`. Those names are there mostly for our convenience.

In the 2nd line we are defining the variables that we will pass to the database as well as their types. The variables in GraphQL are preceded with the dollar sign (`$`).

In the line 4th we are using the function that will create a new record in the database.

The 6th line defines to which table we would like to save our new record.

From line 7th we are starting to list all of the properties that we want to update, and we are using the variable defined in line 2 to save it in the given property. So we will save the variable `$title` in the property called `title` of our table `item`.

There is also the line 12th. Each query we run will return some data. This is the line where we can define what we want to get back after runing the query. In our case we will want the query to return an `id` of the newly created record and the `title` that was saved to the database. The returned result will be a _hash_ (or an _object_ if you are comming from the JavaScript world).


### Test out the query

We have the query written and saved in a `.graphql` file. How can we be sure the query does what we want it to?

In the toolset available when `pos-cli gui serve <instance alias>` is running, we have an app called _GraphiQL_. This is a tool that allows us to test our queries. In the top text field we can **paste our query**. Then, there is a bottom panel called _Query variables_ that we need to expand. This would be the place to **pass the variables** we defined for the query. So, in our case it can be:


```javascript
{
  "title": "Do the groceries"
}
```

Clicking the big _play_ button at the top will run the query. The result of it should be available in the right panel. If everything went OK we should see the `id` and `title`, exactly as we requested for the query results.

```javascript
{
  "data": {
    "record": {
      "id": "1",
      "title": "Do the groceries"
    }
  }
}
```

<img loading="lazy" src="{{ 'images/get-started/todo/gui_graphiql_mutation.jpg' | asset_url }}" alt="GraphiQL running the test query for our To do app">

Please remember that the queries you run in _GraphiQL_ are operating on an actual database for your instance! This means that if you remove any data, it will be actually removed from your database.

This also means, that after running our query, we can now go to the Records section of the `pos-cli gui serve` tool and see our first item in the `item` table (like described in the [section above](#browse-the-database-models-using-platformos-tool)).



## Saving user input in the database

{% render 'svg/save-data-to-database' %}

To save the data that the user provided in our application we need three things: a [form with an input](/get-started/build-your-first-app/building-the-user-interface#a-to-do-app-necessary-interface-elements), a GraphQL query that will [save the data](/get-started/build-your-first-app/saving-data-to-the-database#save-the-data-in-the-database) and a page that will become a bridge between the user input and the query.

If you are following this tutorial, we already have a form on our index page, we just wrote the GraphQL query, so the only thing left would be to build a page that will take the data from the `<form>` and pass it to the query.

To do this, let’s create a new page: `/app/views/pages/item/create.liquid`:

#### /app/views/pages/item/create.liquid

{% raw %}
```liquid
---
method: post
---

{% liquid
	graphql result = 'item/create', title: context.params.title

	if result.record.id
		redirect_to '/'
	else
		echo 'Something went wrong'
		echo result.errors
	endif
%}
```
{% endraw %}

The page we are creating will accept some data from the user, so we want it to be available when it will be requested with the `POST` http method. On platformOS we define the method that the page will be available for in the page configuration section. This section needs to be placed on top of the page. The configuration needs to be placed between those lines with three dashes (`---`).

```liquid
---
method: post
---
```

When we want to write a little more Liquid than just a single line, we need to put the code between those special {% raw %}`{% liquid %}`{% endraw %} tags.

{% raw %}
```liquid
{% liquid
 [...]
%}
```
{% endraw %}

This is a place where we are executing our GraphQL query. We are runing the query located in /app/graphql/item/create.graphql, but we don’t need to pass the whole path, as the platform knows where to look for the queries. We defined a variable called $title in our graphql, so we need to pass it to the query, but we don’t want it to be empty, that’s why we are assigning a value context.params.title to it. All of the query params passed to the page will be always available in the context.params variable.

{% raw %}
```liquid
graphql result = 'item/create', title: context.params.title
```
{% endraw %}

If you remember, our GraphQL query will return the id and the title of the record we’ve just added. In this line we will make sure the query ended successfully by checking if the id is present in the results.

```liquid
if result.record.id
```

If the query went succesfully, we would like to redirect the user from our /item/create page to the index page. This is achieved with the help of Liquid’s redirect_to tag.

```liquid
redirect_to '/'
```

In case something with the query went wrong, we would like to show the error that the GraphQL returns.

```liquid
else
  echo 'Something went wrong'
  echo result.errors
endif
```

If you never seen Liquid before, don’t worry – the syntax will become familiar after a little bit of using it.

The last thing left for us to do before testing the whole thing, would be to add the URL to our newly created page in the `<form>` so that when user submits the form, it will redirect to the page that controlls the process of saving the data. Let’s get back to `/app/view/pages/index.liquid` and update the code:

#### /app/view/pages/index.liquid

```html
<form action="/item/create" method="post">
```

### Testing the flow

To test out the whole flow we just need to get to the homepage of our application, put some text in the input field, and click the _Add item_ button.

We need to remember that we don’t pull the data from the database yet, so nothing on the page will actually change. That’s no problem since we know that we can [browse database records](#browse-the-database-tables-using-platformos-tool) using the tools from `pos-cli gui serve`.


{% render 'alert/next', content: 'Retrieving and presenting the data on the page', url: '/get-started/build-your-first-app/retrieving-and-presenting-the-data-on-the-page/' %}
