---
metadata:
  title: Roles and Permissions
  description: TODO
converter: markdown
---

## Configure roles and permissions

The module is fully functional as-is, but most projects will customize it.

Because module files should never be edited directly, first let's create a local override in your own `app/` directory. The recommended first override is the **permissions configuration**, which defines RBAC roles and permissions for your application.

Run: 

<pre class="command-line" data-user="user" data-host="host"><code class="language-bash">
mkdir -p app/modules/user/public/lib/queries/role_permissions
cp modules/user/public/lib/queries/role_permissions/permissions.liquid \
   app/modules/user/public/lib/queries/role_permissions/permissions.liquid
</code></pre>

This creates a safe override that allows you to define your own roles and permissions without modifying module files directly.

{% include 'alert/tutorial', content: 'For additional setup details and configuration options, refer to the <a href="https://github.com/Platform-OS/pos-module-user?tab=readme-ov-file#setup" target="_blank">User Module README</a> on GitHub.' %}

So it's an override. So this file is defined by the module, but you want to modify it.

Instead of modifying the module file, which is not a good idea, because if you update the module, then you would remove, you know, all of your changes, right? That's why you want a separate file that is based and will be used instead of a module file, right? And here is a simple JSON.

## Roles

It's useful to also have anonymous user as a role because for things like session creation, so logging in, you don't want to authenticate that role to have permission to do it, right? Because they already authenticate or reset password patch, right? It shouldn't be accessible by a logged in user. So that's why we have this anonymous role to grant permission to pages that should be only available for a person who is not logged in. 

And now, then you have authenticated role and this is any logged in user. So maybe, you know, you might have pages like dashboard, for example, where we display in the context of e-commerce, we display all of your orders, for example, right? Or shopping cart, something like that. And in order to view those pages, you need to be logged in. So you can already use, you know, this built-in role and don't have to create your own roles for every single feature. This is like the most common scenario.

And finally, super admin. Super admin has access to everything, right? 
That's the idea. But we will not be using super admin. We'll be adding our own role.

So what you've done previously, which you might not remember, is that you copied the permission file. It was the first step in the setup. And this file is inside the app, modules, user public lib and permissions.

So it's an override. So this file is defined by the module, but you want to modify it.

Instead of modifying the module file, which is not a good idea, because if you update the module, then you would remove, you know, all of your changes, right? That's why you want a separate file that is based and will be used instead of a module file, right? And here is a simple JSON.

#### app/modules/user/public/lib/queries/role_permissions/permissions.liquid

{% raw %}
```liquid
{% parse_json data %}
{
 {% if context.constants.USER_DEFAULT_ROLE != blank %}
 "{{ context.constants.USER_DEFAULT_ROLE }}": [],
 {% endif %}
 "anonymous": ["sessions.create", "users.register"],
 "authenticated": ["sessions.destroy","oauth.manage"],
 "admin": ["admin_pages.view", "admin.users.manage", "users.impersonate"],
 "member": ["profile.manage"],
 "superadmin": ["users.impersonate_superadmin"]
}
{% endparse_json %}


{% return data %}
```
{% endraw %}

Maybe it's not super simple because of this if statement and default role, but in general, it's a simple JSON where you list all permissions that each of the roles has. And you can create your own role. So here you can see that we have actually five roles.

We have anonymous, we have authenticated, we have admin, and we have member, and then super admin. So we already have admin. If you wanted to add your role, let's say buyer or seller, for example, for e-commerce or, you know, I don't know, agency manager, something like that, you would just, yes, exactly.
You would just create a new key, and then you would list all of the permissions that they would have.

```json
 "anonymous": ["sessions.create", "users.register"],
 "authenticated": ["sessions.destroy","oauth.manage"],
 "admin": ["admin_pages.view", "admin.users.manage", "users.impersonate"],
 "member": ["profile.manage"],
 "superadmin": ["users.impersonate_superadmin"],
 "manager": [" "]
}
```

So now you've added a new role, "manager".

We can actually keep this manager, you know? Let's assume that this will be the role that we'll use. So what we want is to add permission for admin page, right?

So we need to figure out a name for this permission, right? So the convention that we have, but it's not super unified and documented, but the first part of the permission is the resource you want to access, right? In this scenario, it would be admin. So we can call it admin and then dot, and after the dot comes what you want to be able to do with this admin, right? It can be view, it can be manage, it can be, I don't know, list, add, create, delete, for example. Like, it really is up to you to determine how granular the permission should be.
Now, I don't really like to make really granular permissions because I assume that if you can create something, you can probably also edit it and delete it. It may not be the case for everything, but it's a good rule of thumb. So that's why you might often see things like manage.

```json
 "manager": ["admin.view"]
``` 

Like, you have in admin, `admin.users.manage`, right? It means that you can ban users, block them, unblock them, you can edit them, you can change their passwords, you know? You can do everything. So this is like internal manage. So let's say that in admin, we just have admin.manage because we are admin.view. Let's say just admin.view because we want to, for now, have access to the admin panel itself. Yeah, there are admin pages. This comes from Peter's module, I believe, back in the day. You can also use the same, but I want you to create your own permission and your own user rule so you see how everything is sticked together.
So let's stick with admin.view, for example. Or if you have a better idea, you can use your own. Perfect.
So you can save it. OK, great. And now, if you go to admin page, views/pages/admin in the code.

OK, now we need to somehow tell PlatformOS that, OK, only user with this permission should be able to do it. Now, right? And you do it for the code. But 

## Authorization commands: `can_do`

OK, so now you can go to the documentation of the module and scroll down a little bit. Here is the code that is adding manually or using code roles to a user.


https://github.com/Platform-OS/pos-module-user?tab=readme-ov-file#authorization-commands 

And the magic happens within this can_do command. So there is a family of methods. can_do will just return you true or false if the requester, which would be your user, has access to his role that has any role with a permission, right? Because one user might have multiple roles, right? So I can be admin. I can be authenticated. I can be seller. I can be agency owner, for example, right? It's OK from the system perspective. I can have many roles.

So at least one of those roles needs to have a permission. And can_do helper is the one to go. Now, typically, you also want to take an action in case a user doesn't have permission. And this is where those more detailed commands come into picture. canDo or unauthorized, it will render for or free error if you don't have the permission. canDo will just return false, but do nothing, right? can_do or unauthorized will actually break the flow of the website. So it will stop executing the website. And it will just display, it will render the partial name that you provided as an argument.
And if you scroll down a little bit, you have also can_do or redirect command, right? So this is when you enter the website to which you do not have permission, it will stop the execution and it will redirect to you somewhere else. So, for example, if you want to access dashboards and you're not logged in, it should redirect you somewhere else.
We have a utility, meaning that you might want to do something different from UX perspective, depending if someone is logged in or not. And you will see the parameters if you scroll to the right, I guess in this can_do or unauthorized, if you scroll right, you will see it's scroll right, not down top, but to the right. Because you only display a portion of the code. Yes, it is redirect anonymous to login flag at the end. It's above, here. Right?

{% raw %}
```liquid
function current_profile = 'modules/user/helpers/current_profile'
# platformos-check-disable ConvertIncludeToRender, UnreachableCode
include 'modules/user/helpers/can_do_or_unauthorized', requester: current_profile, do: 'users.register', redirect_anonymous_to_login: true
# platformos-check-enable ConvertIncludeToRender, UnreachableCode
```
{% endraw %}

So, what this does is that it will render a 403 error page if you are unauthorized, unless you are not logged in. If you are not logged in, it will redirect you to the login form. You will be able to log in then. It will redirect you back to this website you tried to access. And only then, if you still don't have access, only then it will render 403. So, it's a nice UX, right? Because sometimes the browser locks you off or something like that. So, it's just a nice UX to redirect. I'm not logged in users to the login form sometimes.

Okay. So, let's copy. Let's do the unauthorized. (copied from github readme)

{% raw %}
```liquid
function current_profile = 'modules/user/helpers/current_profile'
# platformos-check-disable ConvertIncludeToRender, UnreachableCode
include 'modules/user/helpers/can_do_or_unauthorized', requester: current_profile, do: 'users.register', redirect_anonymous_to_login: true
# platformos-check-enable ConvertIncludeToRender, UnreachableCode
```
{% endraw %}


Copy it to app/views/pages/admin/index.liquid
{% raw %}
```liquid
{% liquid
function current_profile = 'modules/user/helpers/current_profile'
# platformos-check-disable ConvertIncludeToRender, UnreachableCode
include 'modules/user/helpers/can_do_or_unauthorized', requester: current_profile, do: 'users.register', redirect_anonymous_to_login: true
# platformos-check-enable ConvertIncludeToRender, UnreachableCode
%}
Hello
```
{% endraw %}

And type here, hello. Okay


And okay. So, what this method does? It's, first of all, it takes the current profile, right?

So, this is the helper. And behind the scenes, it uses this context.current.user that we discussed, right? You can control+click

[code opens in VScode, modules/user/public/lib/helpers/current_profile.liquid]

See? Okay, and what it does? It loads the current user in line number two. And if you click this, current, you will finally see this magical context.currentuser.id, right?

[modules/user/public/lib/queries/user/current.liquid]

So, in the second, in the sixth line. So, it provides the argument to the load, right? And if the user exists, it returns it. Otherwise, it returns null. And please go to the current_profile.liquid for one more second. All right, so we get the current user. But then we also get the current profile.

And this is a bit unintuitive, I think. And also something that probably our channel partners will be confused. Because for simplicity, right, for simplicity, a lot of people assume that, you know, user is a user, and that's it, right? But in more complex applications, this doesn't work. And also, you cannot, you know, distinguish or you cannot do anything for not logged in or anonymous user, for example, right? So, we have two main concepts that comes with the user module.

First is user. And anything related to user is related to authentication or authentication, really, right? So, are you who you say you are?
That's the question. And profile, profile already is responsible for authorization. Because profile has roles. User doesn't have roles, okay? We change it. It used to have, but we move it to the profile. And profile also has an entity, like, you know, first name, last name, or a business name. Profile can be organization profile. So, instead of first name, last name, it might have a company name, for example. But both might have an address, right? So, that's a profile. Profile is like an abstraction layer over something to which you authenticate it, let's say, or to some kind of entity, like.
Yes, the profile holds the data, the permissions, which applies to the user.
Yeah. And the magic part is that in line number four, you can see that if you are not logged in user, which means user.id == null, then we actually create anonymous profile, right? So, it has no user association, because user is null. But it has roles. And this role is anonymous. That's how we assign this automatically, this role.

Yes, so the profile is created automatically when you register, right? So, when you sign up, we create two things. First of all, we create user with your email and password. But also, we create a profile. In this simple scenario, you had to enter first name and last name on top of email and password, right? In the signup form that you filled yesterday. So, this first name and last name, those are stored inside the profile. Email as well, for caching purposes. Because maybe just for optimizations, we don't need to ‑‑ we just want to duplicate the email and store it in profile as well. And we create those default roles for a profile as well. Right.

And can I view somewhere these profiles? Or, I mean, there is a database tied to it? Or is there a UI for it?



So, let's go to GUI serve. And to localhost. Okay. And go to database. And you can see the module's user profile, right?

[SCREENSHOT TODO]
Database-profiles.png

And this is your profile, right? We have C names, which is just for caching, for filtering, and so on. We have email, duplicate as I mentioned, first name, last name, and so on. And roles, as you can see. Right.

Okay. And actually, that's good that you mentioned. Now, okay. So, we've added the code. Let's ‑‑ we know how this loading current profile works, right? So, let's get back to our admin page in the code.

{% raw %}
```liquid
{% liquid
function current_profile = 'modules/user/helpers/current_profile'
# platformos-check-disable ConvertIncludeToRender, UnreachableCode
include 'modules/user/helpers/can_do_or_unauthorized', requester: current_profile, do: 'users.register', redirect_anonymous_to_login: true
# platformos-check-enable ConvertIncludeToRender, UnreachableCode
%}
Hello
```
{% endraw %}


And now you have this permission number in line number four, right? So, you include can do or unauthorized. This is the built‑in function from the user module. It will prevent you from viewing a page to which you don't have access. The requester is current profile. That's correct, that you fetch it in line number two. And then the do means the permission that you want to check. So, you check if user has permission to do, you know, this permission.
So, now you need to change users.register with the permission that you want to check, to what you previously set for the manager role:
 "manager": ["admin.view"]

Please note that you absolutely do not care about the role here. You are not checking if user has certain role because you don't ‑‑ you can care less, right? What you care about is that if at least one of those roles has this permission. And the user might have multiple roles and multiple roles might have this permission, right? So, you're not checking roles. You're checking permissions associated with those roles.

That's why I'm confused because I expected to declare that it's a manager. So, I want to give a manager role to this current user. And you don't. Because, you know, you might have multiple roles to have the same permission. So, imagine, you know, you have, like, a super admin that has access to this page, right? And then you have a regular admin. And maybe you have, like, you know, a technical writer who should have access to the admin panel and should be able to read things but shouldn't delete anything, for example, right? But, you know, there will be ‑‑ so, you don't want to list roles with something.
You just want to change permission. Because later, maybe you will create a new role, right? And instead of changing million places, right, imagine you have 100 pages in admin, right? And every single page you check for roles. And then you want to add a new role. And this new role should have access to all those 100 pages. Now, you would need to go through every single page of those hundreds and add another role. This is exactly what we want to avoid with this logic, right? Instead, you go to one permission file.
You add a new role. You add permission. And everything works magically. Because this role now has the permission. So, that's the reason why you check permissions. You don't check roles. 

You can actually click this'modules/user/helpers/can_do_or_unauthorized' to see how it's implemented. Okay.

And here, behind the scenes, it uses the can do. Guys. And then you have requester roles in line number 21. So, this checks if you are not logged in. And redirect anonymity to login is true. We'll just redirect people to sessions/new, as you can see. Because it all happens inside the can. So, we first check if the user has permission to do something.
So, if you go to this can do, so click line number 19 to enter the implementation here. Okay. Here you can see that we expect requester, which is our current profile, to have roles, right? And this is the name of the column in the database. And we expect these roles to be an array. If it's not an array, we will log an error that something is wrong. So, at minimum, it should be empty array, right? And this is the default. Okay. And then we just check those permissions, right? So, for every single role, this is in line number 27, we have a loop, right? For every single role within this requester roles, we check the permission file, which returns JSON, right?
