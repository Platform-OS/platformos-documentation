---
metadata:
  title: Authorization commands: can_do
  description: TODO
converter: markdown
---

THIS IS A DRAFT 

## Authorization commands: `can_do`

OK, so now you can go to the documentation of the module and scroll down a little bit. Here is the code that is adding manually or using code roles to a user.

https://github.com/Platform-OS/pos-module-user?tab=readme-ov-file#authorization-commands 

And the magic happens within this can_do command. So there is a family of methods. can_do will just return you true or false if the requester, which would be your user, has access to his role that has any role with a permission, right? Because one user might have multiple roles, right? So I can be admin. I can be authenticated. I can be seller. I can be agency owner, for example, right? It's OK from the system perspective. I can have many roles.

So at least one of those roles needs to have a permission. And can_do helper is the one to go. Now, typically, you also want to take an action in case a user doesn't have permission. And this is where those more detailed commands come into picture. canDo or unauthorized, it will render for or free error if you don't have the permission. canDo will just return false, but do nothing, right? can_do or unauthorized will actually break the flow of the website. So it will stop executing the website. And it will just display, it will render the partial name that you provided as an argument.
And if you scroll down a little bit, you have also can_do or redirect command, right? So this is when you enter the website to which you do not have permission, it will stop the execution and it will redirect to you somewhere else. So, for example, if you want to access dashboards and you're not logged in, it should redirect you somewhere else.
We have a utility, meaning that you might want to do something different from UX perspective, depending if someone is logged in or not. And you will see the parameters if you scroll to the right, I guess in this can_do or unauthorized, if you scroll right, you will see it's scroll right, not down top, but to the right. Because you only display a portion of the code. Yes, it is redirect anonymous to login flag at the end. It's above, here. Right?

{% raw %}
```liquid
function current_profile = 'modules/user/helpers/current_profile'
# platformos-check-disable ConvertIncludeToRender, UnreachableCode
include 'modules/user/helpers/can_do_or_unauthorized', requester: current_profile, do: 'users.register', redirect_anonymous_to_login: true
# platformos-check-enable ConvertIncludeToRender, UnreachableCode
```
{% endraw %}

So, what this does is that it will render a 403 error page if you are unauthorized, unless you are not logged in. If you are not logged in, it will redirect you to the login form. You will be able to log in then. It will redirect you back to this website you tried to access. And only then, if you still don't have access, only then it will render 403. So, it's a nice UX, right? Because sometimes the browser locks you off or something like that. So, it's just a nice UX to redirect. I'm not logged in users to the login form sometimes.

Okay. So, let's copy. Let's do the unauthorized. (copied from github readme)

{% raw %}
```liquid
function current_profile = 'modules/user/helpers/current_profile'
# platformos-check-disable ConvertIncludeToRender, UnreachableCode
include 'modules/user/helpers/can_do_or_unauthorized', requester: current_profile, do: 'users.register', redirect_anonymous_to_login: true
# platformos-check-enable ConvertIncludeToRender, UnreachableCode
```
{% endraw %}


Copy it to app/views/pages/admin/index.liquid
{% raw %}
```liquid
{% liquid
function current_profile = 'modules/user/helpers/current_profile'
# platformos-check-disable ConvertIncludeToRender, UnreachableCode
include 'modules/user/helpers/can_do_or_unauthorized', requester: current_profile, do: 'users.register', redirect_anonymous_to_login: true
# platformos-check-enable ConvertIncludeToRender, UnreachableCode
%}
Hello
```
{% endraw %}

And type here, hello. Okay


And okay. So, what this method does? It's, first of all, it takes the current profile, right?

So, this is the helper. And behind the scenes, it uses this context.current.user that we discussed, right? You can control+click

[code opens in VScode, modules/user/public/lib/helpers/current_profile.liquid]

See? Okay, and what it does? It loads the current user in line number two. And if you click this, current, you will finally see this magical context.currentuser.id, right?

[modules/user/public/lib/queries/user/current.liquid]

So, in the second, in the sixth line. So, it provides the argument to the load, right? And if the user exists, it returns it. Otherwise, it returns null. And please go to the current_profile.liquid for one more second. All right, so we get the current user. But then we also get the current profile.

And this is a bit unintuitive, I think. And also something that probably our channel partners will be confused. Because for simplicity, right, for simplicity, a lot of people assume that, you know, user is a user, and that's it, right? But in more complex applications, this doesn't work. And also, you cannot, you know, distinguish or you cannot do anything for not logged in or anonymous user, for example, right? So, we have two main concepts that comes with the user module.

First is user. And anything related to user is related to authentication or authentication, really, right? So, are you who you say you are?
That's the question. And profile, profile already is responsible for authorization. Because profile has roles. User doesn't have roles, okay? We change it. It used to have, but we move it to the profile. And profile also has an entity, like, you know, first name, last name, or a business name. Profile can be organization profile. So, instead of first name, last name, it might have a company name, for example. But both might have an address, right? So, that's a profile. Profile is like an abstraction layer over something to which you authenticate it, let's say, or to some kind of entity, like.
Yes, the profile holds the data, the permissions, which applies to the user.
Yeah. And the magic part is that in line number four, you can see that if you are not logged in user, which means user.id == null, then we actually create anonymous profile, right? So, it has no user association, because user is null. But it has roles. And this role is anonymous. That's how we assign this automatically, this role.

Yes, so the profile is created automatically when you register, right? So, when you sign up, we create two things. First of all, we create user with your email and password. But also, we create a profile. In this simple scenario, you had to enter first name and last name on top of email and password, right? In the signup form that you filled yesterday. So, this first name and last name, those are stored inside the profile. Email as well, for caching purposes. Because maybe just for optimizations, we don't need to ‑‑ we just want to duplicate the email and store it in profile as well. And we create those default roles for a profile as well. Right.

And can I view somewhere these profiles? Or, I mean, there is a database tied to it? Or is there a UI for it?



So, let's go to GUI serve. And to localhost. Okay. And go to database. And you can see the module's user profile, right?

[SCREENSHOT TODO]
Database-profiles.png

And this is your profile, right? We have C names, which is just for caching, for filtering, and so on. We have email, duplicate as I mentioned, first name, last name, and so on. And roles, as you can see. Right.

Okay. And actually, that's good that you mentioned. Now, okay. So, we've added the code. Let's ‑‑ we know how this loading current profile works, right? So, let's get back to our admin page in the code.

{% raw %}
```liquid
{% liquid
function current_profile = 'modules/user/helpers/current_profile'
# platformos-check-disable ConvertIncludeToRender, UnreachableCode
include 'modules/user/helpers/can_do_or_unauthorized', requester: current_profile, do: 'users.register', redirect_anonymous_to_login: true
# platformos-check-enable ConvertIncludeToRender, UnreachableCode
%}
Hello
```
{% endraw %}


And now you have this permission number in line number four, right? So, you include can do or unauthorized. This is the built‑in function from the user module. It will prevent you from viewing a page to which you don't have access. The requester is current profile. That's correct, that you fetch it in line number two. And then the do means the permission that you want to check. So, you check if user has permission to do, you know, this permission.
So, now you need to change users.register with the permission that you want to check, to what you previously set for the manager role:
 "manager": ["admin.view"]

Please note that you absolutely do not care about the role here. You are not checking if user has certain role because you don't ‑‑ you can care less, right? What you care about is that if at least one of those roles has this permission. And the user might have multiple roles and multiple roles might have this permission, right? So, you're not checking roles. You're checking permissions associated with those roles.

That's why I'm confused because I expected to declare that it's a manager. So, I want to give a manager role to this current user. And you don't. Because, you know, you might have multiple roles to have the same permission. So, imagine, you know, you have, like, a super admin that has access to this page, right? And then you have a regular admin. And maybe you have, like, you know, a technical writer who should have access to the admin panel and should be able to read things but shouldn't delete anything, for example, right? But, you know, there will be ‑‑ so, you don't want to list roles with something.
You just want to change permission. Because later, maybe you will create a new role, right? And instead of changing million places, right, imagine you have 100 pages in admin, right? And every single page you check for roles. And then you want to add a new role. And this new role should have access to all those 100 pages. Now, you would need to go through every single page of those hundreds and add another role. This is exactly what we want to avoid with this logic, right? Instead, you go to one permission file.
You add a new role. You add permission. And everything works magically. Because this role now has the permission. So, that's the reason why you check permissions. You don't check roles. 

You can actually click this'modules/user/helpers/can_do_or_unauthorized' to see how it's implemented. Okay.

And here, behind the scenes, it uses the can do. Guys. And then you have requester roles in line number 21. So, this checks if you are not logged in. And redirect anonymity to login is true. We'll just redirect people to sessions/new, as you can see. Because it all happens inside the can. So, we first check if the user has permission to do something.
So, if you go to this can do, so click line number 19 to enter the implementation here. Okay. Here you can see that we expect requester, which is our current profile, to have roles, right? And this is the name of the column in the database. And we expect these roles to be an array. If it's not an array, we will log an error that something is wrong. So, at minimum, it should be empty array, right? And this is the default. Okay. And then we just check those permissions, right? So, for every single role, this is in line number 27, we have a loop, right? For every single role within this requester roles, we check the permission file, which returns JSON, right?
