---
converter: markdown
metadata:
  title: Refactoring Views
  description: Tutorial on how to build e-commerce sites powered by PlatformOS
slug: use-cases/e-commerce/refactoring-views
searchable: true
---

{% include 'use-cases/e-commerce/tutorial-info' %}

So far you haven’t written much code, but there are already some cases that will benefit greatly from refactoring:

- [shared partials for fetching common data](#shared-partials)
- [form field partials](#form-field-partials)

## Shared partials for fetching common data

Some information is reused over and over in your application. When you’ve built the admin panel logic, you had to keep checking over and over again in different places if current user has admin access flag set to true. So far each time you needed to do that, you called `current_user` query and check appropriate field value. Imagine though, that further down the road in the project, additional business logic is put in place, that changes this condition. You will have to go in, and updated all of these places in code.

{% capture content %}
This problem is not new and every programming project has to deal with it in one way or the other. What we propose below is just a convention, and not a definitive and only way of approaching this issue.
{% endcapture %}
{% include 'alert/note', content: content %}

### Step1. Create a shared partial

Start with moving data fetching to separate partial in `shared` namespace.

#### marketplace_builder/views/partials/shared/get_current_user.liquid

```liquid
{% raw %}
{% query_graph 'get_current_user_data', result_name: "current_user_g" %}

{% if current_user_g.current_user %}
  {{
    current_user_g.current_user
      | assign_to_hash_key: 'has_admin_access', current_user_g.current_user.profile.properties.admin
      | json
  }}
{% else %}
{}
{% endif %}
{% endraw %}

```

In the above code snippet you’ve:

1. Fetched the data with query
2. Added a new field `has_admin_access` to returned object (which is a reference to another field down the properties tree)
3. Printed it out as JSON

Now, anytime you want to fetch current user data you can go ahead and write

```liquid
{% raw %}
{% parse_json current_user %}
  {% include 'shared/current_user' %}
{% endparse_json %}
{% endraw %}
```

You will then have access to `current_user.has_admin_access` variable. This example might seem too convoluted, but there are certain upsides to this convention:

1. Every variable is defined explicitly. By generating / parsing JSON you avoided creating a variable to magically appears in the template where you’ve included your partial, leaving any future developers scratching their heads.
2. You can extend logic attached to current user in one place, and make it available everywhere else.

### Step 3. Rename `current_user` query

Rename query `marketplace_builder/graph_queries/user/current_user.liquid` to `marketplace_builder/graph_queries/user/get_current_user_data.liquid` and update query name inside the file.

{% capture content %}
Liquid implementation comes with a certain feature you have to be aware of. [Documentation for `include`](https://www.rubydoc.info/gems/liquid/Liquid/Include) tag mentions, that you you can use `for` and `with` keywords to pass a variable that will named after the partial name.

This variable is created every time, even if you do not use `for` or `with` keywords (it’s simply blank). It cannot be overwritten, so it’s important to avoid creating new variables or calling queries that are called the same as the partial file.
{% endcapture %}
{% include 'alert/tip', content: content %}

### Step 2. Update files fetching `current_user` data

Make changes to the two files that had this logic before.

#### marketplace_builder/authorization_policies/admin_user.liquid

```liquid
{% raw %}
---
name: admin_user
redirect_to: /unauthorized
flash_alert: Sorry, you have to be an admin user to access this page.
---
{% parse_json current_user %}
  {% include 'shared/get_current_user' %}
{% endparse_json %}
{% if current_user.has_admin_access %}true{% endif %}
{% endraw %}
```

#### marketplace_builder/form_configurations/session/sign_in_form.liquid

```liquid
{% raw %}
---
name: sign_in_form
resource: Session
flash_notice: 'You are now logged in'
redirect_to: >
  {%- parse_json current_user -%}
    {% include 'shared/get_current_user' %}
  {%- endparse_json -%}
  {%- if current_user.has_admin_access -%}
    /admin
  {%- else -%}
    /
  {%- endif -%}
...
{% endraw %}
```

## Form field partials

Another prime candidate for refactoring are form field inputs. Form components can be rendered using `form_builder` variable, available inside of every form configuration html content section.

This variable contains all of the information regarding every field - it’s name, current value, validation rules and possible errors attached to the field.

Having this in place you can easily build shared partials, that will accept a `form_builder.fields` entry and generate the required control in a consistent manner.

{% capture content %}
For the sake of brevity, this tutorial includes only one example, for regular `<input type="text">` field. You will probably need to create one partial per control type as the application grows.
{% endcapture %}
{% include 'alert/note', content: content %}

{% comment %}
TODO: Add a link to the form_builder beginners tutorial once it’s out
{% endcomment %}

#### `form_builder.fields` sample entry

```json
{
  ...
  "fields": {
    "email": {
      "name": "form[email]",
      "value": "",
      "validation": {
        "errors": ["Please enter your email"],
        "rules": {
          "presence": {
            "message": "Please enter your email"
          },
          "email": {
            "message": "Provided email is invalid"
          }
        }
      },
      "property_options": null
    }
  }
}
```

Let’s quickly dissect particular properties:

- `name` and `value` represent matching html attributes for any html input
- `validation` contains both the rules that should be applied to the input (very useful to add validation on the frontend as we’ll see in just a moment) and actual validation errors if any occurred during last form submit.
- `property_options` contains additional configuration options but these do not apply to building shared form input partials

### Step 1. Create shared partials

Let’s take a look at how you could structure the shared partial, to make it configurable and use values provided by `form_builder`

#### marketplace_builder/views/partials/forms/fields/text.liquid

```liquid
{% raw %}
{% comment %}
  Required params:
    field: hash
    label: string

  Optional:
    id: string
    type: string
    hint: string
    readonly: boolean
    disabled: boolean
{% endcomment %}

{%- assign _type = type | default: 'text' -%}
{%- assign _error = field.validation.errors.first -%}
{%- assign _default_id = field.name | slugify -%}
{%- assign _id = id | default: _default_id -%}

{%- assign _value = field.value -%}
{%- if _type == 'password' %}
  {% assign _value = '' %}
{%- endif -%}

{%- assign _readonly = readonly | default: false -%}
{%- assign _disabled = disabled | default: false -%}

{%- if field.validation.rules.presence != blank -%}
  {%- assign _required = true -%}
{%- else -%}
  {%- assign _required = false -%}
{%- endif -%}

<div class="form-group">
  {%
    include 'forms/label' with label,
      for_id: _id,
      hint: hint,
      required: _required
  %}

  <input
    type="{{ _type }}"
    class="form-control{% if _error != blank %} is-invalid{% endif %}"
    id="{{ _id }}"
    name="{{ field.name }}"
    value="{{ _value }}"
    {% if _readonly %} readonly {% endif %}
    {% if _required %} required {% endif %}
    {% if _disabled %} disabled {% endif %}
  />

  {% include 'forms/error' with _error %}
</div>

{% endraw %}
```

#### marketplace_builder/views/partials/forms/error.html

```liquid
{% raw %}
{% comment %}
  Required params:
    error: string
{% endcomment %}
{%- if error != blank -%}
  <div class="invalid-feedback">{{ error }}</div>
{%- endif -%}
{% endraw %}
```

#### marketplace_builder/views/partials/forms/label.html

```liquid
{% raw %}
{% comment %}
  Required params:
    for_id: string
    label: string

  Optional params
    required: boolean
    hint: string

{% endcomment %}
<label for="{{ for_id }}">
  {{ label }}
  {% unless required %}<span>(Optional)</span>{% endunless %}

  {%- if hint != blank -%}
    <div><small class="form-text text-muted">{{ hint | html_safe }}</small></div>
  {%- endif -%}
</label>
{% endraw %}
```

This example can be split into three separate parts and as a pattern reused throughout the application

1. Top comment contains a list of all required and optional parameters that can be passed and will be used in this partial. It’s easier this way to see at a glance what options are available
2. Assign values part - most of the optional parameters should have some kind

{% capture content %}
You should always reset values of all variables at the top of the partial. In case of `_required` you could have omitted the `else` section and just assume if it’s not assigned then the default blank applies. However, if any of the previous partials did set the value for the variable, it would leak into your partial.
{% endcapture %}
{% include 'alert/warning', content: content %}

3. Rendering part. It’s recommended to split common components into their own separate partials. Whenever you want to make a change to either `label` or `error` elements, they will be used in all fields, so once more you do not have to repeat yourself.

### Step 2. Update existing forms

With partial in place you can now update your one existing form `sign_in_form`

#### marketplace_builder/form_configurations/session/sign_in_form.liquid

```liquid
{% raw %}
---
name: sign_in_form
resource: Session
flash_notice: 'You are now logged in'
redirect_to: >
  {%- parse_json current_user -%}
    {% include 'shared/get_current_user' %}
  {%- endparse_json -%}
  {%- if current_user.has_admin_access -%}
    /admin
  {%- else -%}
    /
  {%- endif -%}

configuration:
  email:
    validation:
      presence:
        message: Please enter your email
      email:
        message: Provided email is invalid
  password:
    validation:
      presence:
        message: Password is required
---

{% form %}

  {%
    include "forms/fields/text",
      label: 'Email',
      field: form_builder.fields.email,
      type: "email"
  %}

  {%
    include "forms/fields/text",
      label: 'Password',
      field: form_builder.fields.password,
      type: "password"
  %}

  {% include "forms/submit", label: 'Sign in' %}

{% endform %}
{% endraw %}
```

For good measure it’s recommended to keep all common elements in their own partails, so go ahead and create default submit partial

#### marketplace_builder/views/partials/forms/submit.liquid

```liquid
{% raw %}
{% comment %}
  Optional params:
    label: string
{% endcomment %}

{% assign _label = label | default: "Submit" %}

<div class="form-group row">
  <div class="col-sm-12">
    <button type="submit" class="btn btn-primary">{{ _label }}</button>
  </div>
</div>
{% endraw %}
```

## Summary

Presented sample is a simple one and there is a lot more that you can do:

- add additional optional attributes like `autocomplete` or `placeholder`
- support for `data-` attributes by passing a hash of options
- extend default HTML5 validation by parsing `validation` rules provided by `form_builder`
- use {% raw %}`{% log "{message}", type: "error" %}`{% endraw %} tag to mark an error anytime a require parameter is missing in the partial

With these simple changes you are now ready to start building the admin panel in earnest. In the next part you’ll define all constants and enums for your application, so it’s easier than relying on magical strings.

{% include 'use-cases/e-commerce/nav' %}

{% include 'shared/questions_section' %}
